#!/usr/bin/env python
# -*- coding:utf-8 -*-
def findCheapestPrice(n, flights, src, dst, K):
    '''
    @Author : possibleit
    @Date : 12:49 2019/3/30
    @Description :
        描述：有n个城市被一些航班所连接。每个航班 (u,v,w) 从城市u出发，到达城市v，价格为w。给定城市数目 n，所有的航班flights。你的任务是找到从起点src到终点站dst的最便宜线路的价格，而旅途中最多只能中转K次。如果没有找到合适的线路，返回 -1。
            1总城市数 n 在 1-100 之间，每个城市被标号为 0 到 n-1。
            2航线的总数在 0 到 n * (n - 1) / 2 之间
            3每条航线会被以 [出发站，终点站，价格] 的形式展现。
            4每条航线的价格都在 1-10000之间。
            5中转站的总数限制范围为 0 到 n-1 之间。
            6不会有重复或者自环航线出现
    @Example :
        输入:
            n = 3,
            flights = [[0,1,100],[1,2,100],[0,2,500]],
            src = 0, dst = 2, K = 0
        输出: 500
    @Solution :
        解题思路是使用Bellman-Ford算法
        利用此算法解出从原点到所有目标点的距离，最后查表得出需要的那个点的距离即可
        例： n = 3,
            flights = [[0,1,100],[1,2,100],[0,2,500]],
            src = 0, dst = 2, K = 0

            K | 0 |   1   |   2   |
        ------|---|-------|-------|------
        初始化 | 0 | 10001 | 10001 |
        ------|---|-------|-------|------
            0 | 0 |  100  |  500  |
        ------|---|-------|-------|------
            1 | 0 |  100  |  200  |
        ------|---|-------|-------|------
        控制遍历次数K即可
    '''
    distance = []
    for i in range(n):
        distance.append(10001)
    distance[src] = 0
    for i in range(K+1):
        dN = distance
        for j in flights:
            #只会更新存在的路径，即对于一个目标点，会遍历所有以他为结束点的边并取最小值
            dN[j[1]] = min(dN[j[1]],distance[j[0]] + j[2])
        distance = dN
    if distance[dst] == 10001:
        return -1
    return distance[dst]
s = [[3,4,4],[2,5,6],[4,7,10],[9,6,5],[7,4,4],
     [6,2,10],[6,8,6],[7,9,4],[1,5,4],[1,0,4],
     [9,7,3],[7,0,5],[6,5,8],[1,7,6],[4,0,9],
     [5,9,1],[8,7,3],[1,2,6],[4,1,5],[5,2,4],
     [1,9,1],[7,8,10],[0,4,2],[7,2,8]]
print(findCheapestPrice(10,s,6,0,7))